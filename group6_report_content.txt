Technical  Report:  Hybrid  PoW  +  PoS  DApp  
MVP
 
Sprint  4  Comprehensive  Documentation  &  Strategic  Analysis  
1.  Introduction  &  Methodological  Framework  This  report  provides  a  deep-dive  technical  analysis  of  the  Flight  Delay  Insurance  (FDI)  DApp.  
Beyond
 
technical
 
specifications,
 
this
 
document
 
dissects
 
the
 
architectural
 
decisions
 
using
 
advanced
 
innovation
 
and
 
risk
 
frameworks
 
including
 
SCAMPER,
 
TRIZ,
 
FMEA,
 
and
 
5
 
Whys,
 
ensuring
 
that
 
every
 
line
 
of
 
code
 
serves
 
a
 
strategic
 
business
 
purpose.
 
Our  core  innovation  is  a  Hybrid  Consensus  Model  (Proof-of-Work  +  Proof-of-Stake)  that  resolves  the  
classic
 
blockchain
 
trilemma,
 
offering
 
the
 
security
 
of
 
PoW
 
with
 
the
 
scalability
 
of
 
PoS.
 
2.  Frontend  Architecture  (Sprint  1)  Product  Name:  FlightGuard  -  Decentralized  Flight  Insurance  DApp  Version  /  Release:  1.0  MVP  Objective:  Deliver  a  responsive,  SEO-optimized  user  interface  for  seamless  flight  booking  and  insurance  purchasing  Prepared  By:  Elturan  Aliyev  and  Yelmar  Farhadov  Report  Date:  16/12/2024  Summary:  Frontend  built  with  Next.js  16,  React  19,  and  TailwindCSS  for  high-performance  SSR  and  Web3  integration   
The  frontend  is  the  primary  touchpoint  for  our  users,  designed  for  trust,  speed,  and  accessibility.  
2.1  Technology  Stack  &  Justification  •  Next.js  16  (App  Router):  Chosen  for  its  robust  Server-Side  Rendering  (SSR).  Why  SSR?   unlike  
client-side
 
SPAs,
 
SSR
 
ensures
 
our
 
insurance
 
products
 
are
 
indexable
 
by
 
search
 
engines
 
(Critical
 
for
 
SEO)
 
and
 
provides
 
fast
 
'First
 
Contentful
 
Paint'
 
for
 
users
 
on
 
slow
 
mobile
 
connections.
 
•  TailwindCSS:  A  utility-first  CSS  framework.  Why  Tailwind?  It  allows  for  rapid  UI  iteration  
without
 
context-switching
 
to
 
CSS
 
files,
 
significantly
 
reducing
 
development
 
time
 
during
 
the
 
MVP
 
phase.
 
•  Three.js:  Used  for  3D  visualization.  Why  3D?  To  provide  an  immersive  'premium'  feel  that  
differentiates
 
our
 
brand
 
from
 
generic
 
DeFi
 
protocols.
 Methodological  Analysis:  SCAMPER  (Substitute,  Combine,  Adapt...)  
S  –  Substitute:  We  substituted  traditional  client-side  fetching  with  Server  
Actions
 
in
 
Next.js
 
15
 
for
 
better
 
security.
 
C
 
–
 
Combine:
 
We
 
combined
 
standard
 
2D
 
booking
 
forms
 
with
 
3D
 
interactive
 
globes
 
(Three.js)
 
to
 
increase
 
user
 
engagement
 
metrics.
 
Methodological  Analysis:  TRIZ  Principle  1  (Segmentation)  
We  applied  Segmentation  by  breaking  the  UI  into  atomic  components  
(Buttons,
 
Inputs,
 
Cards)
 
in
 
a
 
dedicated
 
UI
 
Kit.
 
This
 
independent
 
modularity
 
increases
 
system
 
flexibility
 
and
 
maintainability.
 
2.2  Landing  Page  Implementation  The  landing  page  implements  the  'AIDA'  (Attention,  Interest,  Desire,  Action)  model,  guiding  users  
from
 
the
 
header
 
(Attention)
 
to
 
the
 
3D
 
globe
 
(Interest)
 
and
 
finally
 
the
 
Search
 
CTA
 
(Action).
 
 
Figure  1:  High-Conversion  Landing  Page  
2.3  Insurance  Integration  Flow  The  insurance  selection  is  seamlessly  integrated  into  the  checkout  flow.  Users  purchase  policies  
covering
 
flight
 
delays,
 
with
 
premiums
 
calculated
 
dynamically
 
off-chain
 
and
 
verified
 
on-chain.
 
 
Figure  2:  Integrated  Insurance  Selection  
3.  Backend  Architecture  (Sprint  1)  Product  Name:  FlightGuard  -  Decentralized  Flight  Insurance  DApp  Version  /  Release:  1.0  MVP  Objective:  Provide  a  scalable,  hybrid  microservices  backend  for  high-concurrency  API  requests  and  blockchain  integration  Prepared  By:  Elturan  Aliyev  and  Yelmar  Farhadov  Report  Date:  16/12/2024  Summary:  Backend  architecture  using  Django  5.0  and  FastAPI  with  PostgreSQL,  Web3.py,  and  comprehensive  logging   
3.1  Hybrid  Microservices  Strategy  Our  backend  architecture  leverages  a  hybrid  approach,  utilizing  both  Django  and  FastAPI.  
•  Django  5.0:  Used  for  core  business  logic,  User  Management,  and  the  Admin  interface.  Why  
Django?
 
The
 
'battery-included'
 
nature
 
(ORM,
 
Auth,
 
Admin)
 
allowed
 
us
 
to
 
build
 
the
 
administrative
 
backbone
 
in
 
record
 
time.
 
•  FastAPI:  Used  for  high-throughput  public  API  endpoints  (e.g.,  Flight  Search,  Price  Feeds).  Why  
FastAPI?
 
It
 
natively
 
supports
 
Python's
 
`asyncio`,
 
enabling
 
non-blocking
 
I/O.
 
This
 
is
 
critical
 
when
 
handling
 
thousands
 
of
 
concurrent
 
flight
 
status
 
updates
 
without
 
bogging
 
down
 
the
 
server
 
threads.
 
Methodological  Analysis:  TRIZ  Principle  5  (Merging)  &  Principle  3  (Local  Quality)  
Merging:  We  merged  the  robustness  of  Django  with  the  speed  of  FastAPI  into  
a
 
single
 
cohesive
 
backend
 
ecosystem.
 
Local
 
Quality:
 
Instead
 
of
 
a
 
monolithic
 
solution,
 
we
 
optimized
 
specific
 
parts
 
(API
 
endpoints)
 
for
 
speed
 
(FastAPI)
 
while
 
keeping
 
others
 
optimized
 
for
 
management
 
(Django).
 
3.2  Logging  and  Monitoring  Strategy  Visibility  is  paramount.  We  integrated  `loguru`  for  structured,  asynchronous  logging.  Every  request  
is
 
tagged
 
with
 
a
 
correlation
 
ID,
 
tracing
 
it
 
from
 
Frontend
 
->
 
API
 
Gateway
 
->
 
Database.
 
Methodological  Analysis:  5  Whys  Framework  (Root  Cause  Analysis)  
1.  Why  do  we  need  extensive  logs?  To  debug  production  issues  quickly.  
2.
 
Why
 
quickly?
 
Because
 
flight
 
delays
 
happen
 
in
 
real-time.
 
3.
 
Why
 
is
 
real-time
 
critical?
 
Users
 
expect
 
instant
 
claim
 
settlement.
 
4.
 
Why
 
the
 
expectation?
 
Trust
 
is
 
the
 
product.
 
5.
 
Conclusion:
 
Logging
 
is
 
not
 
IT
 
maintenance;
 
it
 
is
 
a
 
Trust
 
feature.
 
 
Figure  3:  System  Logs  showing  Request  Lifecycle  
4.  Smart  Contracts  &  Hybrid  Consensus  (Sprint  2)  Product  Name:  FlightGuard  -  Decentralized  Flight  Insurance  DApp  Version  /  Release:  1.0  MVP  Objective:  Implement  secure,  audited  smart  contracts  with  hybrid  PoW+PoS  consensus  and  real-time  ETL  data  pipelines  Prepared  By:  Elturan  Aliyev  Report  Date:  16/12/2024  Summary:  Smart  contracts  in  Solidity  0.8.20  with  Hardhat  testing,  and  ETL  pipelines  for  blockchain-to-database  synchronization   
4.1  Contract  Architecture  Written  in  Solidity  0.8.20,  our  contracts  manage  the  lifeblood  of  the  DApp:  Payments  and  Claims.  We  
use
 
Hardhat
 
for
 
development
 
due
 
to
 
its
 
superior
 
debugging
 
capabilities
 
(console.log)
 
versus
 
Truffle.
 
•  CompanyFunding.sol:  A  liquidity  pool  contract  where  the  insurance  provider  deposits  reserves.  
Why
 
separate?
 
Isoaling
 
funds
 
reduces
 
risk.
 
If
 
the
 
User
 
contract
 
is
 
breached,
 
the
 
main
 
Funding
 
pool
 
remains
 
secure
 
under
 
different
 
access
 
controls.
 
•  UserDelayInsurance.sol:  The  consumer-facing  contract.  It  handles  premium  collection  and  
interacts
 
with
 
the
 
Oracle
 
for
 
flight
 
status.
 
Methodological  Analysis:  FMEA  (Failure  Mode  and  Effects  Analysis)  
Risk:  Re-entrancy  Attack  on  claim  withdrawals.  
Severity:
 
10
 
(Critical
 
Funds
 
Loss).
 
Mitigation:
 
Implemented
 
'Checks-Effects-Interactions'
 
pattern
 
and
 
OpenZeppelin's
 
`ReentrancyGuard`.
 
Resulting
 
Risk
 
Priority
 
Number
 
(RPN):
 
Reduced
 
from
 
90
 
to
 
10
 
(Acceptable).
 
4.2  Verification  and  Gas  Optimization  We  employ  comprehensive  automated  testing  with  Hardhat  to  verify  logic.  Each  test  ensures  that  
state
 
transitions
 
(e.g.,
 
Active
 
->
 
Claimed)
 
occur
 
strictly
 
according
 
to
 
business
 
rules.
 
 
Figure  4:  Hardhat  Test  Suite  Results  (100%  Pass  Rate)  
Gas  optimization  is  a  key  KPI.  We  utilize  the  `hardhat-gas-reporter`  to  continuously  monitor  the  cost  
of
 
execution,
 
ensuring
 
our
 
insurance
 
remains
 
affordable.
 
 
Figure  5:  Gas  Usage  Report  
5.  ETL  &  Data  Pipelines  (Sprint  3)  
5.1  The  "Bridge"  Strategy  Blockchains  are  poor  databases  for  querying  complex  relationships.  To  solve  this,  we  built  an  
Event-Extract-Transform-Load
 
(ETL)
 
pipeline
 
that
 
'bridges'
 
on-chain
 
truth
 
to
 
an
 
off-chain
 
PostgreSQL
 
database.
 
Why  ETL?  Direct  RPC  calls  to  the  blockchain  for  every  page  load  would  be  slow  and  expensive.  Our  
ETL
 
indexes
 
events
 
like
 
`PolicyPurchased`
 
into
 
a
 
relational
 
schema,
 
allowing
 
our
 
Django/FastAPI
 
backend
 
to
 
serve
 
dashboards
 
in
 
milliseconds.
 
Methodological  Analysis:  TRIZ  Principle  10  (Preliminary  Action)  
We  perform  the  'Preliminary  Action'  of  indexing  and  sorting  data  BEFORE  
the
 
user
 
asks
 
for
 
it.
 
This
 
pre-arrangement
 
allows
 
for
 
instant
 
data
 
retrieval,
 
satisfying
 
the
 
'Do
 
It
 
related
 
to
 
P-10'
 
principle.
 
5.2  Pipeline  Components  •  Listener  Service:  Uses  Web3.py  `AsyncWeb3`  to  subscribe  to  WebSocket  headers.  
•
 
Decoder/Mapper:
 
Decodes
 
ABI
 
hex
 
logs
 
into
 
human-readable
 
Python
 
dictionaries.
 
•
 
Reliability
 
Layer:
 
Implements
 
a
 
'backfill'
 
loop
 
that
 
checks
 
for
 
missed
 
blocks
 
(e.g.,
 
during
 
downtime)
 
to
 
ensure
 
eventual
 
consistency.
 
6.  Key  Code  Implementation  To  provide  transparency  into  our  engineering  standards,  we  include  direct  snapshots  of  the  core  
logic
 
files.
 
These
 
snippets
 
demonstrate
 
our
 
adherence
 
to
 
clean
 
code,
 
modular
 
design,
 
and
 
security
 
best
 
practices.
 
6.1  Smart  Contract  Logic:  Funding  &  Insurance  The  following  snippets  show  the  rigorous  access  controls  in  `CompanyFunding.sol`  and  the  policy  
settlement
 
logic
 
in
 
`UserDelayInsurance.sol`.
 
 
Snippet  1:  CompanyFunding.sol  -  Reserves  Management  
 
Snippet  2:  UserDelayInsurance.sol  -  Policy  Logic  
6.2  ETL  Pipeline:  Event  Listener  The  `listener.py`  script  demonstrates  how  we  subscribe  to  on-chain  events  asynchronously,  bridging  
the
 
gap
 
between
 
blockchain
 
and
 
database.
 
 
Snippet  3:  listener.py  -  Async  Event  Subscription  
6.3  Full  Stack  Integration  From  the  backend  API  endpoints  in  `bookings.py`  to  the  frontend  landing  page  in  `page.jsx`,  our  
stack
 
is
 
unified
 
by
 
type
 
safety
 
and
 
clear
 
separation
 
of
 
concerns.
 
 
Snippet  4:  bookings.py  -  Flight  API  Endpoint  
 
Snippet  5:  page.jsx  -  Next.js  Landing  Component  
7.  Conclusion  By  synthesizing  advanced  innovation  methodologies  (SCAMPER,  TRIZ)  with  a  robust  modern  stack  
(Next.js,
 
FastAPI,
 
Solidity),
 
we
 
have
 
delivered
 
a
 
DApp
 
MVP
 
that
 
is
 
technically
 
sound,
 
commercially
 
viable,
 
and
 
strategically
 
defended
 
against
 
risks.
 
This
 
report
 
confirms
 
the
 
readiness
 
of
 
the
 
system
 
for
 
Stage
 
4:
 
Investor
 
Presentation.
 
 
 
Database  Architecture  and  Design  Report  Flyy  -  Flight-Delay  Parametric  Insurance  
Product  Name:  Flyy  
Objective:  Provide  a  robust,  normalized  (4NF),  and  scalable  database  architecture  to  support  parametric  
insurance
 
smart
 
contracts
 
for
 
automated
 
flight
 
delay
 
compensation.
 
Prepared  By:  Yusif  Novruzlu  and  Aysel  Mammadova  
Report  Date:  16/12/2025  
Summary:  Comprehensive  documentation  of  the  relational  database  system  supporting  flight-delay  
parametric
 
insurance,
 
integrated
 
with
 
blockchain
 
smart
 
contracts
 
for
 
automated
 
claim
 
processing.
 
 
EXECUTIVE  SUMMARY  This  project  implements  a  sophisticated  database  architecture  for  a  flight-delay  parametric  insurance  
platform
 
where
 
mutual
 
risk
 
pools
 
automatically
 
compensate
 
policyholders
 
upon
 
verified
 
flight
 
delays.
 
Built
 
on
 
PostgreSQL
 
with
 
Fourth
 
Normal
 
Form
 
(4NF)
 
compliance,
 
the
 
system
 
ensures
 
zero
 
data
 
redundancy
 
and
 
optimal
 
query
 
performance.
 
 
The  architecture  comprises  9  core  tables  with  strategic  indexing,  materialized  views  for  analytics,  and  
unified
 
status
 
management.
 
The
 
design
 
prioritizes
 
data
 
integrity
 
through
 
foreign
 
key
 
constraints,
 
transaction
 
atomicity
 
for
 
financial
 
operations,
 
and
 
audit
 
trails
 
for
 
regulatory
 
compliance.
 
 
Key  Achievements:  
●  4NF  Normalization:  Elimination  of  multi-valued  dependencies  ●  Smart  Contract  Integration:  Schema  optimized  for  oracle  event  consumption  and  automated  payouts  ●  Query  Performance:  Strategic  indexing  providing  100x  speedup  (1200ms  →  12ms)  ●  Data  Integrity:  Referential  integrity  constraints  preventing  orphaned  records  ●  Scalability:  Materialized  views  enabling  sub-second  queries  on  aggregated  data  
The  unified  StatusLookup  table  reduces  storage  overhead  by  40%  while  maintaining  semantic  clarity.  
 
INTRODUCTION   2.1  Background  Parametric  insurance  triggers  payouts  based  on  predefined  parameters  rather  than  assessed  losses.  In  
flight-delay
 
insurance,
 
if
 
a
 
flight
 
is
 
delayed
 
beyond
 
a
 
threshold
 
(e.g.,
 
3
 
hours),
 
the
 
payout
 
executes
 
automatically
 
via
 
smart
 
contracts.
 
This  hybrid  architecture  uses  a  relational  database  for  high-volume  transactional  data  while  blockchain  
handles
 
trustless
 
value
 
transfer
 
based
 
on
 
oracle-provided
 
data.
 
2.2  Project  Objectives  Key  goals:  
●  Real-time  policy  and  claim  management  ●  Centralized  visibility  through  analytics  dashboards  ●  Automated  claim  processing  via  oracle  integration  ●  ACID  guarantees  for  financial  transactions  ●  4NF  compliance  for  data  integrity  
Smart  Contract  Integration  Points:  RiskPool,  PolicyNFT,  Pricing,  Oracle,  Payouts  WORKFLOW  OVERVIEW  
1.  User  Books  Flight  →  Creates  Booking  and  Ticket  records  
2.  User  Purchases  Insurance  →  InsurancePolicy  created,  PolicyNFT  minted  
3.  Premium  Payment  →  Payment  record  with  financial  reconciliation  
4.  Oracle  Monitors  Flight  →  Detects  delays  exceeding  threshold  
5.  Automated  Claim  Initiation  →  InsuranceClaim  created  with  tiered  payout  
calculation
 
6.  Smart  Contract  Payout  →  Verifies  policy,  executes  transfer  from  RiskPool  
7.  Post-Payout  Updates  →  Status  changes  to  'Claimed',  reserves  decremented  
8.  Analytics  →  Materialized  views  aggregate  data  for  risk  management  
SYSTEM  DESIGN  AND  ARCHITECTURE  
3.1  High-Level  Architecture  Layer  1:  Core  Transactional  Tables  (User,  Flight,  Booking,  Ticket,  InsurancePolicy,  Payment,  
InsuranceClaim)
 
Layer
 
2:
 
Reference
 
Tables
 
(StatusLookup,
 
Developer)
 
Layer
 
3:
 
Optimization
 
Layer
 
(Indexes,
 
Materialized
 
Views)
 
Layer
 
4:
 
Integration
 
Layer
 
(Oracle
 
Connector,
 
Smart
 
Contract
 
Interface)
 
3.2  Technology  Stack  ●  PostgreSQL  14+:  ACID  compliance,  advanced  indexing,  materialized  views  ●  4NF  Normalization:  Eliminates  multi-valued  dependencies  ●  B-Tree  Indexes:  Accelerate  joins  on  foreign  keys  and  date  fields  ●  Materialized  Views:  Pre-computed  aggregations  for  dashboard  performance  
DATABASE  SCHEMA  DESIGN  (4NF  COMPLIANCE)  
4.1  Normalization  to  4NF  1NF:  All  columns  atomic  (no  arrays)  2NF:  All  non-key  attributes  depend  on  entire  primary  key  3NF:  No  
transitive
 
dependencies
 
4NF:
 
Eliminates
 
multi-valued
 
dependencies
 
via
 
unified
 
StatusLookup
 
table
 
 
 4.2  StatusLookup  Table  (4NF  Cornerstone)  Schema:  
CREATE  TABLE  StatusLookup  ( 
    statusId  SERIAL  PRIMARY  KEY, 
    statusType  VARCHAR(20)  NOT  NULL, 
    code  VARCHAR(30)  NOT  NULL, 
    UNIQUE(statusType,  code) 
); 
Advantages:  
●  Zero  redundancy  (status  codes  stored  once)  ●  Atomic  updates  (change  terminology  in  one  place)  ●  Type  safety  (statusType  enforces  semantic  boundaries)  ●  Referential  integrity  (invalid  status  assignments  prevented)  
Example  Data:  22  status  codes  across  4  entity  types  (flight,  booking,  policy,  payment)  
 
 
TABLE  SPECIFICATIONS   
5.1  User  Table  CREATE  TABLE  "User"( 
    user_id  SERIAL  PRIMARY  KEY, 
    name  VARCHAR(100)  NOT  NULL, 
    email  VARCHAR(100)  NOT  NULL  UNIQUE, 
    phone  VARCHAR(20) 
); 
Purpose:  Customer  identity  for  policy  ownership  Key  Feature:  Email  uniqueness  prevents  duplicate  
accounts
 
 
●    
5.2  Flight  Table  CREATE  TABLE  Flight( 
    flightId  SERIAL  PRIMARY  KEY, 
    origin  VARCHAR(100)  NOT  NULL, 
    destination  VARCHAR(100)  NOT  NULL, 
    departureTime  TIMESTAMP  NOT  NULL, 
    arrivalTime  TIMESTAMP  NOT  NULL, 
    statusId  INT  NOT  NULL  REFERENCES  StatusLookup(statusId) 
); 
Purpose:  Flight  schedules  and  real-time  status  for  delay  verification  Index:  idx_flight_destination  for  
geographic
 
reporting
 
 
●   
 
5.3  Booking  Table  CREATE  TABLE  Booking( 
    bookingId  SERIAL  PRIMARY  KEY, 
    user_id  INT  NOT  NULL  REFERENCES  "User"(user_id), 
    flightId  INT  NOT  NULL  REFERENCES  Flight(flightId), 
    bookingDate  TIMESTAMP  NOT  NULL, 
    statusId  INT  NOT  NULL  REFERENCES  StatusLookup(statusId) 
); 
Purpose:  Links  users  to  flights  Indexes:  idx_booking_user,  idx_booking_flight  Relationships:  1  User  →  N  
Bookings,
 
1
 
Flight
 
→
 
N
 
Bookings
 
 
●   
 5.4  Ticket  Table  CREATE  TABLE  Ticket( 
    ticketId  SERIAL  PRIMARY  KEY, 
    bookingId  INT  NOT  NULL  REFERENCES  Booking(bookingId), 
    seatNumber  VARCHAR(20)  NOT  NULL, 
    company  VARCHAR(100)  NOT  NULL, 
    price  NUMERIC(10,2)  NOT  NULL, 
    issueDate  TIMESTAMP  NOT  NULL, 
    isPremium  BOOLEAN  DEFAULT  FALSE 
); 
Purpose:  Seat  assignments  and  pricing  Key  Feature:  isPremium  flag  influences  insurance  pricing  
 
●   
 
5.5  InsurancePolicy  Table  CREATE  TABLE  InsurancePolicy( 
    policyId  SERIAL  PRIMARY  KEY, 
    bookingId  INT  NOT  NULL  REFERENCES  Booking(bookingId), 
    coverageAmount  NUMERIC(10,2)  NOT  NULL, 
    premium  NUMERIC(10,2)  NOT  NULL, 
    statusId  INT  NOT  NULL  REFERENCES  StatusLookup(statusId) 
); 
Purpose:  Coverage  terms  and  policy  lifecycle  Smart  Contract:  policyId  maps  to  PolicyNFT  token  ID  
Business
 
Rule:
 
premium
 
=
 
2-5%
 
of
 
coverageAmount
 
 
●   
 
5.6  Payment  Table  CREATE  TABLE  Payment(     paymentId  SERIAL  PRIMARY  KEY, 
    bookingId  INT  NOT  NULL  REFERENCES  Booking(bookingId), 
    amount  NUMERIC(10,2)  NOT  NULL, 
    paymentMethod  VARCHAR(50)  NOT  NULL, 
    paymentDate  TIMESTAMP  NOT  NULL, 
    statusId  INT  NOT  NULL  REFERENCES  StatusLookup(statusId) 
); 
Purpose:  Financial  transaction  records  Indexes:  idx_payment_booking,  idx_payment_date  Validation:  
amount
 
=
 
Ticket.price
 
+
 
InsurancePolicy.premium
 
 
●   
 
5.7  InsuranceClaim  Table  CREATE  TABLE  InsuranceClaim( 
    claimId  SERIAL  PRIMARY  KEY, 
    policyId  INT  NOT  NULL  REFERENCES  InsurancePolicy(policyId), 
    delayDuration  FLOAT  NOT  NULL, 
    claimStatus  VARCHAR(50)  NOT  NULL, 
    payoutAmount  NUMERIC(10,2)  NOT  NULL 
); 
Purpose:  Delay  events  and  automated  payouts  Payout  Logic:  
●  2-4  hours:  50%  of  coverage  ●  4-6  hours:  75%  of  coverage  ●  6+  hours:  100%  of  coverage  ●   
 
5.8  Entity  Relationships  User  (1)  →  (N)  Booking  (N)  ←  (1)  Flight  Booking  (1)  →  (1)  Ticket  Booking  (1)  →  (0..1)  InsurancePolicy  (1)  
→
 
(N)
 
InsuranceClaim
 
Booking
 
(1)
 
→
 
(N)
 
Payment
 
StatusLookup
 
(1)
 
→
 
(N)
 
Flight,
 
Booking,
 
InsurancePolicy,
 
Payment
  
 
QUERY  OPTIMIZATION  AND  INDEXING   
6.1  Index  Strategy  CREATE  INDEX  idx_booking_user  ON  Booking(user_id); 
CREATE  INDEX  idx_booking_flight  ON  Booking(flightId); 
CREATE  INDEX  idx_ticket_booking  ON  Ticket(bookingId); 
CREATE  INDEX  idx_policy_booking  ON  InsurancePolicy(bookingId); 
CREATE  INDEX  idx_payment_booking  ON  Payment(bookingId); 
CREATE  INDEX  idx_claim_policy  ON  InsuranceClaim(policyId); 
CREATE  INDEX  idx_payment_date  ON  Payment(paymentDate); 
CREATE  INDEX  idx_flight_destination  ON  Flight(destination); 
Performance  Impact:  100x  speedup  for  user  bookings  query  (1200ms  →  12ms)  
6.2  Materialized  View  CREATE  MATERIALIZED  VIEW  mv_monthly_payouts  AS 
SELECT 
    f.destination, 
    date_trunc('month',  p.paymentDate)  AS  month, 
    SUM(ic.payoutAmount)  AS  total_payout 
FROM  InsuranceClaim  ic 
JOIN  InsurancePolicy  ip  ON  ip.policyId  =  ic.policyId 
JOIN  Booking  b  ON  b.bookingId  =  ip.bookingId 
JOIN  Flight  f  ON  f.flightId  =  b.flightId 
JOIN  Payment  p  ON  p.bookingId  =  b.bookingId 
GROUP  BY  f.destination,  date_trunc('month',  p.paymentDate); 
Performance:  450ms  refresh  for  50K  claims,  5ms  dashboard  queries  END  OF  REPORT   
 
Security  and  Monitoring  Report  
FLYY.com  
 
Product  Name:  XWASIAM  ( Extended  Web  Application  Security  Intelligence  and  Automation  Management )  
Version  /  Release:  1.2  
Objective:  Provide  an  integrated  all  in  one  platform  to  detect,  prevent,  and  respond  to  cyber  threats  in  
all
 
possible
 
web
 
application
 
vectors.
 
Prepared  By:  Gurban  Bannayev  
Report  Date:  16/12/2025  
Summary:  Overview  of  the  project,  components  built.  
 
Executive  Summary  In  the  contemporary  landscape  of  digital  threats,  securing  web  applications  requires  more  than  just  
reactive
 
measures;
 
it
 
demands
 
a
 
proactive,
 
layered
 
defense
 
ecosystem.
 
This
 
project
 
implements
 
a
 
sophisticated
 
cybersecurity
 
platform
 
integrating
 
three
 
pivotal
 
components:
 
a
 
Web
 
Application
 
Firewall
 
(WAF)
 
for
 
real-time
 
traffic
 
inspection,
 
a
 
Security
 
Information
 
and
 
Event
 
Management
 
(SIEM)
 
system
 
for
 
centralized
 
log
 
analysis,
 
and
 
a
 
Security
 
Orchestration,
 
Automation,
 
and
 
Response
 
(SOAR)
 
module
 
for
 
autonomous
 
threat
 
mitigation.
 
The  developed  solution  functions  as  a  cohesive  unit.  The  WAF  leverages  Linux  kernel  `NetfilterQueue`  to  
intercept
 
and
 
analyze
 
HTTP
 
traffic
 
at
 
the
 
network
 
layer,
 
applying
 
deep
 
packet
 
inspection
 
(DPI)
 
to
 
identify
 
attacks
 
such
 
as
 
SQL
 
Injection
 
(SQLi)
 
and
 
Cross-Site
 
Scripting
 
(XSS).
 
Upon
 
detection,
 
the
 
SOAR
 
engine
 
executes
 
an
 
immediate
 
response
 
by
 
temporarily
 
banning
 
the
 
malicious
 
IP
 
address
 
and
 
notifying
 
security
 
administrators
 
via
 
Telegram.
 
Simultaneously,
 
the
 
SIEM
 
component
 
ingests
 
logs
 
from
 
both
 
the
 
WAF
 
and
 
the
 
web
 
server,
 
visualizing
 
security
 
posture
 
through
 
a
 
dynamic
 
dashboard.
 
Testing  results  demonstrate  the  system’s  efficacy:  it  successfully  blocked  100%  of  injected  SQL  and  XSS  
payloads
 
and
 
enforced
 
rate
 
limits
 
with
 
sub-second
 
precision.
 
By
 
automating
 
the
 
detection-to-response
 
pipeline,
 
the
 
platform
 
reduces
 
the
 
window
 
of
 
exposure
 
from
 
minutes
 
to
 
milliseconds,
 
proving
 
its
 
viability
 
as
 
a
 
robust
 
educational
 
prototype
 
for
 
modern
 
protection
 
strategies.
 
---  Introduction  
2.1  Background  Web  applications  are  the  primary  interface  for  digital  business  but  are  also  the  most  frequent  targets  of  
cyberattacks.
 
The
 
Open
 
Web
 
Application
 
Security
 
Project
 
(OWASP)
 
Top
 
10
 
consistently
 
highlights
 
vulnerabilities
 
like
 
Injection
 
and
 
Broken
 
Access
 
Control
 
as
 
critical
 
risks.
 
Traditional
 
firewalls
 
(layer
 
3/4)
 
are
 
insufficient
 
against
 
these
 
application-layer
 
(layer
 
7)
 
attacks,
 
necessitating
 
specialized
 
tools
 
like
 
WAFs.
 
Furthermore,
 
the
 
sheer
 
volume
 
of
 
logs
 
generated
 
by
 
modern
 
infrastructure
 
overwhelms
 
human
 
analysts,
 
driving
 
the
 
need
 
for
 
SIEM
 
systems
 
to
 
correlate
 
data
 
and
 
SOAR
 
tools
 
to
 
automate
 
responses.
 
2.2  Project  Scope  or  Objectives  The  primary  objective  of  this  project  was  to  design  and  implement  a  "Purple  Team"  environment—a  
defensive
 
setup
 
that
 
can
 
be
 
actively
 
tested
 
against
 
offensive
 
techniques.
 
Key  goals  included:  
●    Real-time  Traffic  Analysis :  Creating  a  custom  WAF  capable  of  inspecting  specific  patterns  in  HTTP  
headers
 
and
 
bodies.
 ●    Centralized  Visibility :  Building  a  SIEM  dashboard  to  provide  a  "single  pane  of  glass"  view  of  the  
security
 
state.
 ●    Closed-Loop  Automation :  Implementing  SOAR  logic  where  detection  triggers  an  immediate,  
unassisted
 
response
 
(IP
 
banning).
 ●    Alerting :  Ensuring  stakeholders  are  notified  instantly  of  high-severity  incidents.  
Work  Flow   
Attacker  attacks  (this  is  typical  XSS  attack  in  the  visual)  :  
 
XWASIAM  successfully  detects  the  attack  in  real-time  and  blocks  the  request,  preventing  it  from  
reaching
 
the
 
web
 
server
 
:
 
 
We  can  also  see  the  alert  it  created  in  the  SIEM  with  details  of  the  attack(its  timestamp,  actor,  event  
type,
 
level,
 
detailed
 
information
 
about
 
the
 
attack)
 
:
 
 
As  you  can  see  while  the  WAF  is  running  on  Prevention  Mode  (BLOCKING_ENABLED)  the  IP  address  of  
the
 
attacker
 
is
 
blocked
 
for
 
a
 
certain
 
time
 
:
 
 
The  diagrams  are  also  showing  the  statistics  perfectly  
 
 
The  System  Administrator  can  see  the  details  of  the  action  from  terminal  too  :  
 
In  case  the  SOC  analyst  is  away  from  the  monitor  or  on  they  are  on  the  shift,  the  alert  will  also  notify  
them
 
via
 
telegram
 
or
 
any
 
integrated
 
related
 
app
 
immediately,
 
ensuring
 
no
 
delays
 
in
 
response.
 
That
 
is
 
how
 
big
 
companies
 
nowadays
 
implement
 
:
 
 
Let’s  check  out  the  DOS  attack  senario  too.  I  generated  DOS  attack  myself  for  testing  purposes  on  the  
server
 
and
 
let’s
 
see
 
the
 
results.
 
As
 
you
 
can
 
see
 
while
 
I
 
set
 
the
 
rete
 
limit
 
100request
 
per
 
minute
 
after
 
100
th
 
malicious
 
request,
 
it
 
is
 
not
 
accepting
 
(response
 
code
 
429
 
is
 
TOO
 
MUCH
 
REQUEST
 
identificator)
 
 
 
And  also  the  actor  is  banned  for  exceeding  the  rate  limit  :  
 
System  Design  and  Architecture  
3.1  High-Level  Architecture  ●    The  Interceptor  (WAF) :  Sits  inline  with  network  traffic.  It  acts  as  a  gateway,  deciding  which  packets  
pass
 
to
 
the
 
application
 
and
 
which
 
are
 
dropped.
 
It
 
is
 
the
 
"muscle"
 
of
 
the
 
operation.
 
●    The  Brain  (SIEM) :  Acts  as  the  data  warehouse.  It  receives  telemetry  from  the  WAF  (alerts)  and  the  
web
 
server
 
(access
 
logs),
 
normalizing
 
this
 
data
 
for
 
analysis.
 ●    The  Responder  (SOAR) :  Acts  as  the  reflex  system.  It  maintains  the  "state"  of  the  network  (e.g.,  list  
of
 
banned
 
IPs)
 
and
 
executes
 
actions
 
based
 
on
 
WAF
 
triggers.
 
3.2  Technology  Stack  Justification  ●    Language :  Python  3.9+  was  chosen  for  its  rich  ecosystem  of  security  libraries  (`scapy`)  and  rapid  
prototyping
 
capabilities.
 ●    Packet  Manipulation :  `Scapy`  and  `NetfilterQueue`  were  selected  to  allow  raw  manipulation  of  
IP/TCP
 
packets,
 
providing
 
granular
 
control
 
over
 
traffic
 
that
 
standard
 
proxy-based
 
WAFs
 
might
 
abstract
 
away.
 ●    Backend  Framework :  `FastAPI`  provides  high-performance,  asynchronous  endpoints  critical  for  
handling
 
bursts
 
of
 
log
 
ingestion
 
traffic.
 ●    Data  Storage :  `SQLite`  was  used  for  its  simplicity  and  zero-configuration  deployment,  suitable  for  an  
educational
 
MVP,
 
though
 
replacable
 
with
 
PostgreSQL
 
for
 
production.
 ●    Visualization :  `Dash`  (by  Plotly)  offers  strictly  analytical  UI  components,  making  it  superior  to  
general-purpose
 
web
 
frameworks
 
for
 
rendering
 
time-series
 
security
 
data.
 
---  
Component  Implementation:  Web  Application  Firewall  (WAF)  The  WAF  is  the  most  complex  component,  operating  at  the  intersection  of  network  engineering  and  
application
 
security.
 
It
 
does
 
not
 
merely
 
read
 
logs;
 
it
 
actively
 
interferes
 
with
 
network
 
traffic.
 
4.1  Packet  Interception  with  NetfilterQueue  The  WAF  relies  on  Linux's  `iptables`  to  divert  traffic  to  a  user-space  queue.  
●    Command :  `iptables  -I  INPUT  -p  tcp  --dport  80  -j  NFQUEUE  --queue-num  1`  ●    Mechanism :  This  rule  instructs  the  kernel  to  look  at  any  TCP  packet  destined  for  port  80.  Instead  of  
delivering
 
it
 
to
 
the
 
destination
 
application
 
immediately,
 
the
 
kernel
 
places
 
the
 
packet
 
in
 
Queue
 
#1.
 ●    Python  Integration :  The  `waf.py`  script  binds  to  this  queue.  For  every  packet,  it  extracts  the  payload  
and
 
converts
 
it
 
into
 
a
 
`scapy`
 
IP
 
object.
 
This
 
allows
 
the
 
script
 
to
 
read
 
(and
 
potentially
 
modify)
 
headers
 
and
 
payloads
 
before
 
issuing
 
a
 
verdict:
 
`packet.accept()`
 
or
 
`packet.drop()`.
 
4.2  Deep  Packet  Inspection  (DPI)  Logic  Once  a  packet  is  captured,  the  WAF  reconstructs  the  TCP  payload  to  identify  HTTP  messages.  
1.   Extraction :  The  script  strips  headers  to  find  the  HTTP  body.  
2.   Decoding :  It  handles  URL-encoding  (`%20`,  `%27`)  to  prevent  evasion  techniques  where  attackers  
encode
 
malicious
 
characters.
 
3.   Pattern  Matching :  The  core  detection  engine  uses  Python's  `re`  module  with  pre-compiled  regex  
signatures.
 4.3  Rate  Limiting  Algorithm  To  mitigate  DoS  attacks,  the  WAF  implements  a  Fixed  Window  Counter  algorithm.  
●    Data  Structure :  A  dictionary  mapping  IP  addresses  to  lists  of  request  timestamps:  `Dict[IP,  
List[Timestamp]]`.
 ●    Flow :  
1.   On  each  packet,  prune  timestamps  older  than  the  window  (e.g.,  60  seconds).  
2.   Check  the  count  of  remaining  timestamps.  
3.   If  count  >  Threshold  (100),  trigger  Rate  Limit  logic  (Drop  packet  &  Send  429  Response).  
4.   Else,  append  current  timestamp  and  allow.  
●    Response :  Unlike  silent  drops,  the  WAF  actively  constructs  a  new  TCP  packet  with  an  HTTP  `429  Too  
Many
 
Requests`
 
status
 
and
 
injects
 
it
 
back
 
to
 
the
 
client,
 
ensuring
 
the
 
user
 
knows
 
they
 
are
 
throttled.
 
---  
Component  Implementation:  SIEM  The  SIEM  moves  beyond  detection  to  analysis,  providing  the  historical  context  needed  for  forensics.  
5.1  Log  Ingestion  Pipeline  The  ingestion  layer  addresses  the  challenge  of  heterogeneous  data  sources.  
●    Log  Ingest  Script :  A  standalone  daemon  (`log_ingest.py`)  monitors  the  `access.log`.  It  parses  the  
Common
 
Log
 
Format
 
(CLF)
 
into
 
a
 
structured
 
JSON
 
object
 
comprising
 
`source`,
 
`timestamp`,
 
`method`,
 
`url`,
 
and
 
`status_code`.
 ●    Transformation :  HTTP  status  codes  are  mapped  to  severity  levels:  ●    `5xx`  ->  ERROR  ●    `4xx`  ->  WARNING  ●    `2xx/3xx`  ->  INFO  ●    Resilience :  The  ingestor  implements  a  "tail-f"  mechanism  using  file  seeking  to  read  logs  in  real-time  
without
 
locking
 
the
 
file.
 
It
 
also
 
features
 
a
 
retry
 
loop
 
for
 
API
 
POST
 
requests,
 
ensuring
 
data
 
isn't
 
lost
 
if
 
the
 
SIEM
 
API
 
is
 
temporarily
 
down.
 
5.2  Database  Schema  Persistence  is  handled  by  SQLAlchemy.  The  schema  is  normalized  for  query  efficiency.  
●    Table :  `events`  ●    `id`:  Primary  Key  ●    `timestamp`:  DateTime  (Indexed  for  time-series  querying)  ●    `source`:  String  (IP  Address)  ●    `event_type`:  String  (e.g.,  "SQLi",  "Login",  "/home")  ●    `level`:  String  (Severity)  ●    `message`:  Text  (Raw  log  or  detailed  alert  info)  5.3  Dashboard  &  Visualization  The  Dashboard  is  built  on  the  Plotly  Dash  framework,  which  allows  for  reactive,  callback-based  UI  
updates.
 
●    Real-time  Callback :  An  interval  component  fires  every  5  seconds,  triggering  a  fetch  of  the  last  100  
events
 
from
 
the
 
API.
 ●    Timezone  Intelligence :  The  system  handles  the  complexity  of  mixing  sources.  WAF  alerts  
(generated
 
internally
 
in
 
UTC)
 
and
 
logs
 
(system
 
local
 
time)
 
are
 
normalized
 
efficiently
 
using
 
Pandas
 
`dt.tz_convert`
 
to
 
ensure
 
the
 
timeline
 
graph
 
is
 
accurate.
 ●    Visual  Components :  ●    *Line  Chart*:  Event  volume  over  time  (5-minute  buckets).  ●    *Bar  Chart*:  Attack  types  breakdown  (demonstrating  the  "threat  landscape").  ●    *Table*:  Detailed  event  log  for  drill-down  analysis.  ●    *Status  Panel*:  Live  view  of  currently  banned  and  rate-limited  IPs,  pulled  from  the  WAF's  internal  
state
 
API.
 
---  
Component  Implementation:  SOAR  The  SOAR  module  represents  the  "Active"  defense  capability.  
6.1  State  Management  &  Banning  Logic  The  SOAR  logic  is  embedded  within  the  WAF  capabilities  to  ensure  minimal  latency  (microseconds).  
●    Banning :  When  a  "Critical"  signature  (SQLi/XSS)  is  matched,  the  implementation  does  not  just  drop  
the
 
current
 
packet.
 
It
 
adds
 
the
 
source
 
IP
 
to
 
a
 
`banned_ips`
 
dictionary
 
with
 
an
 
expiration
 
timestamp
 
(`current_time
 
+
 
180s`).
 ●    Enforcement :  Packet  processing  checks  this  ban  list  *before*  running  expensive  regex  matches.  If  
an
 
IP
 
is
 
banned,
 
the
 
packet
 
is
 
eagerly
 
dropped.
 
This
 
"fail-fast"
 
mechanism
 
protects
 
the
 
WAF
 
CPU
 
from
 
being
 
overwhelmed
 
by
 
a
 
persistent
 
attacker.
 
6.2  External  Communication  (Telegram)  Human  awareness  is  maintained  via  API  integration.  
●    Trigger :  The  `telegram.send_alert()`  function  is  called  asynchronously  upon  detection.  ●    Deduplication :  To  prevent  "alert  fatigue"  (spamming  the  admin  with  1000  messages  for  a  single  
brute-force
 
attack),
 
the
 
system
 
implements
 
a
 
dampening
 
logic.
 
It
 
tracks
 
the
 
`last_alert_time`
 
for
 
each
 
`(IP,
 
AttackType)`
 
pair
 
and
 
silences
 
notifications
 
if
 
a
 
previous
 
one
 
was
 
sent
 
within
 
the
 
last
 
60
 
seconds.
 ●    Payload :  The  alert  is  rich-text  formatted  (HTML),  providing  the  analyst  with:  ●    Attack  Type  (e.g.,  "SQL  Injection")  ●    Source  IP  ●    The  specific  Payload  snippet  that  triggered  the  rule  (e.g.,  `UNION  SELECT  *`).  
---  Testing  &  Evaluation  
7.1  Methodology  Testing  was  conducted  using  a  "Black  Box"  approach.  The  system  played  the  role  of  the  defender,  while  a  
separate
 
Kali
 
Linux
 
machine
 
acted
 
as
 
the
 
attacker.
 
Tools
 
used
 
included
 
`curl`,
 
`ab`
 
(Apache
 
Bench),
 
and
 
custom
 
Python
 
attack
 
scripts.
 
7.2  Functional  Test  Cases  &  Results  Test  Case  ID  Description  Payload/Action  Expected  Outcome  
Actual  Result  
TC-001  SQL  Injection  Prevention  
GET  `/?q='  OR  1=1  --`  WAF  Blocks  (403),  Alert  Sent  
Pass.  Connection  reset.  Telegram  alert  received.  TC-002  XSS  Prevention  POST  body  `<script>alert(1)</script>`  
WAF  Blocks  (403),  Alert  Sent  
Pass.  Request  dropped.  Dashboard  showed  "XSS".  TC-003  Command  Injection  
GET  `/?cmd=;  cat  /etc/passwd`  
WAF  Blocks  (403),  IP  Banned  
Pass.  IP  banned  for  180s.  
TC-004  Rate  Limit  Enforcement  
150  requests  in  10  sec  via  `ab`  
Requests  >  100  get  429  code  
Pass.  100  success,  50  failures  (429).  TC-005  False  Positive  Check  
GET  `/search?q=union_of_sets`  
Traffic  Allowed  (200  OK)  
Pass.  Keyword  "union"  alone  did  not  trigger.  
7.3  Performance  Evaluation  ●    Latency :  The  overhead  introduced  by  the  WAF  was  measured.  ●    *Baseline  (No  WAF)*:  ~2ms  RTT.  ●    *With  WAF  (Clean  traffic)*:  ~5ms  RTT.  ●    *Conclusion*:  The  3ms  overhead  is  negligible  for  standard  web  applications  but  highlights  the  
efficiency
 
of
 
the
 
Python-based
 
NFQueue
 
implementation.
 ●    Throughput :  The  system  handled  ~200  requests/second  before  showing  signs  of  CPU  saturation  
(due
 
to
 
Python's
 
GIL),
 
which
 
is
 
acceptable
 
for
 
the
 
project
 
scope.
 
---  
Security  Considerations  
8.1  Strengths  ●    Behavioral  Enforcement :  Unlike  log-based  tools  (Fail2Ban)  that  ban  *after*  the  request  is  
processed,
 
this
 
WAF
 
blocks
 
the
 
request
 
*before*
 
it
 
hits
 
the
 
server,
 
preventing
 
the
 
exploit
 
from
 
ever
 
executing.
 ●    Self-Protection :  The  WAF  protects  the  SIEM  backend  by  filtering  noise.  8.2  Limitations  ●    Bypass  Potential :  Sophisticated  evasions  (e.g.,  splitting  payloads  across  packets)  might  bypass  the  
regex
 
engine.
  
Future  Improvement  Plans  Custom  Query  Language  for  Threat  Hunting  :  
Currently,
 
different
 
SIEM
 
platforms
 
have
 
their
 
own
 
query
 
languages—Splunk
 
uses
 
SPL,
 
ELK
 
uses
 
DSL,
 
IBM
 
QRadar
 
uses
 
AQL,
 
and
 
Microsoft
 
Sentinel
 
uses
 
KQL.
 
Implementing
 
a
 
similar
 
custom
 
query
 
language
 
in
 
our
 
platform
 
will
 
enable
 
threat
 
hunters
 
to
 
analyze
 
logs
 
more
 
efficiently.
 
 
Data  Science  and  Database  Report  
FLYY.com  
 
Product  Name:  Flyy  
Objective:  Provide  a  fully  automated,  blockchain-integrated  parametric  insurance  platform  for  flight  
delays,
 
leveraging
 
advanced
 
machine
 
learning
 
for
 
risk
 
assessment
 
and
 
dynamic
 
pricing.
 
Prepared  By:  Yusif  Novruzlu  and  Aysel  Mammadova  
Report  Date:  16/12/2025  
Summary:  Comprehensive  overview  of  data  science  models,  database  schema,  and  system  architecture.  
 
Executive  Summary  The  Flight-Delay  Parametric  Insurance  application  represents  a  paradigm  shift  in  the  insurance  industry,  
moving
 
from
 
reactive
 
claims
 
processing
 
to
 
proactive,
 
automated
 
smart-contract-based
 
payouts.
 
By
 
integrating
 
real-time
 
flight
 
data
 
with
 
sophisticated
 
predictive
 
modeling,
 
flight-delay.ai
 
offers
 
instantaneous
 
settlement
 
for
 
passengers
 
experiencing
 
verified
 
delays.
 
This
 
report
 
details
 
the
 
data
 
science
 
and
 
database
 
infrastructure
 
that
 
powers
 
this
 
"Mutual
 
Risk
 
Pool"
 
ecosystem.
 
The  core  of  the  system  relies  on  a  suite  of  machine  learning  models  designed  to  assess  risk,  predict  flight  
delays,
 
and
 
optimize
 
pricing
 
dynamically.
 
The
 
platform
 
utilizes
 
an
 
Isolation
 
Forest
 
for
 
anomaly
 
detection
 
in
 
claims,
 
a
 
Random
 
Forest-based
 
Risk
 
Classifier
 
to
 
predict
 
claim
 
probability,
 
and
 
a
 
Gradient
 
Boosting
 
Regressor
 
for
 
dynamic
 
premium
 
pricing.
 
These
 
models
 
are
 
supported
 
by
 
a
 
robust
 
clustering
 
algorithm
 
that
 
segments
 
users
 
based
 
on
 
booking
 
behaviors.
 The  backend  infrastructure  is  built  on  a  relational  database  schema  that  seamlessly  connects  user  
bookings,
 
flight
 
status,
 
insurance
 
policies,
 
and
 
claims.
 
This
 
data-driven
 
approach
 
ensures
 
that
 
the
 
Risk
 
Pool
 
remains
 
solvent
 
while
 
providing
 
fair
 
and
 
transparent
 
coverage
 
to
 
users.
 
The
 
integration
 
of
 
these
 
components
 
allows
 
for
 
sub-second
 
quote
 
generation
 
and
 
automated
 
claim
 
verification,
 
reducing
 
operational
 
costs
 
and
 
enhancing
 
user
 
trust.
 
 
---  
Introduction  
2.1  Background  Parametric  insurance  differs  from  traditional  indemnity  insurance  by  paying  out  when  a  pre-defined  
index
 
(parameter)
 
is
 
triggered,
 
rather
 
than
 
based
 
on
 
assessment
 
of
 
actual
 
loss.
 
In
 
the
 
context
 
of
 
air
 
travel,
 
flight
 
delays
 
are
 
the
 
perfect
 
trigger
 
mechanism.
 
However,
 
accurate
 
pricing
 
and
 
risk
 
management
 
are
 
critical
 
to
 
the
 
sustainability
 
of
 
such
 
a
 
model.
 
Without
 
predictive
 
capabilities,
 
the
 
risk
 
pool
 
could
 
be
 
drained
 
by
 
adverse
 
selection
 
or
 
systematic
 
high-risk
 
routes.
 
This
 
project
 
addresses
 
these
 
challenges
 
through
 
advanced
 
data
 
science.
 
 
2.2  Project  Scope  or  Objectives  The  primary  objective  of  the  Data  Science  division  was  to  build  a  predictive  engine  that  safeguards  the  
mutual
 
risk
 
pool
 
while
 
maximizing
 
user
 
acquisition.
 
Key  goals  included:  
●  •    Risk  Assessment:  Accurately  predicting  the  likelihood  of  a  flight  delay  claim  using  historical  data.  ●  •    Dynamic  Pricing:  Calculating  fair  premiums  that  reflect  the  specific  risk  of  a  route  and  time.  ●  •    Fraud  Detection:  Identifying  anomalous  patterns  in  claims  or  booking  behavior  using  
unsupervised
 
learning.
 ●  •    Customer  Segmentation:  Understanding  user  bases  to  tailor  insurance  products  effectively.  
 
Work  Flow   Business  KPIs  and  Overview:  The  platform  tracks  key  performance  indicators  to  ensure  financial  health.  The  dashboard  below  
visualizes
 
the
 
core
 
metrics
 
such
 
as
 
total
 
premiums
 
collected,
 
payouts,
 
and
 
the
 
overall
 
health
 
of
 
the
 
risk
 
pool.
 
 
 
The  payout  trends  are  closely  monitored  to  detect  seasonal  spikes  in  delays.  This  allows  the  system  to  
adjust
 
reserve
 
requirements
 
dynamically.
 
 
System  Design  and  Architecture  
3.1  High-Level  Architecture  The  system  follows  a  microservices-oriented  architecture  where  the  Data  Science  module  acts  as  an  
intelligent
 
oracle
 
for
 
the
 
smart
 
contracts.
 
●  •    The  Oracle:  Fetches  real-time  flight  status  and  feeds  it  to  the  smart  contracts.  ●  •    The  Pricing  Engine:  Uses  the  Risk  Classifier  and  Price  Regressor  to  generate  quotes.  ●  •    The  Risk  Pool:  Managed  on-chain,  but  modeled  off-chain  to  ensure  solvency.  
 
3.2  Technology  Stack  
●  •    Language:  Python  3.9+  for  all  data  science  tasks.  ●  •    Machine  Learning:  Scikit-learn  for  standard  models,  XGBoost  for  high-performance  gradient  
boosting.
 ●  •    Data  Processing:  Pandas  and  NumPy  for  efficient  data  manipulation.  ●  •    Database:  Relational  structure  (CSV/SQL)  handling  normalized  data  for  Users,  Bookings,  and  
Policies.
 
 
---  
Component  Implementation:  Data  Science  Models  The  intelligence  of  the  platform  is  partitioned  into  specialized  models,  each  addressing  a  specific  aspect  
of
 
the
 
insurance
 
lifecycle.
 
 
4.1  Anomaly  Detection  (Isolation  Forest)  To  prevent  fraud  and  identify  system  errors,  we  employ  an  Isolation  Forest  algorithm.  This  unsupervised  
learning
 
model
 
isolates
 
observations
 
by
 
randomly
 
selecting
 
a
 
feature
 
and
 
then
 
randomly
 
selecting
 
a
 
split
 
value
 
between
 
the
 
maximum
 
and
 
minimum
 
values
 
of
 
the
 
selected
 
feature.
 
●  •    Features  Used:  `total_payment`,  `claim_ratio`,  `days_to_departure`.  ●  •    Purpose:  Detects  unusual  claims  that  deviate  significantly  from  the  norm  (e.g.,  massive  payouts  
on
 
cheap
 
tickets).
 ●  •    Outcome:  Flagged  transactions  are  sent  for  manual  review  before  smart  contract  execution.  
 
 
4.2  Risk  Classifier  (Random  Forest)  The  Risk  Classifier  is  the  gatekeeper  of  the  platform.  It  predicts  whether  a  specific  flight  booking  will  
result
 
in
 
a
 
claim
 
(i.e.,
 
be
 
delayed).
 
●  •    Algorithm:  Random  Forest  Classifier.  ●  •    Target:  `has_claim`  (Binary).  ●  •    Performance:  The  model  achieves  high  accuracy  in  distinguishing  between  low-risk  and  high-risk  
flights,
 
ensuring
 
we
 
don't
 
underprice
 
risky
 
routes.
 
 
 
4.3  Price  Regressor  (Gradient  Boosting)  Once  risk  is  assessed,  the  Price  Regressor  determines  the  fair  premium  amount.  
●  •    Algorithm:  Gradient  Boosting  Regressor.  ●  •    Features:  `days_to_departure`,  `risk_score`  (from  classifier).  ●  •    Target:  `total_payment`  (Premium).  ●  •    Logic:  Closer  departure  dates  and  higher  risk  scores  correlate  with  higher  premiums.  
 
 
4.4  Customer  Segmentation  (K-Means  Clustering)  We  utilize  K-Means  clustering  to  segment  our  user  base  into  distinct  personas  (e.g.,  "Frequent  Business  
Travelers",
 
"Budget
 
Vacationers").
 
●  •    Features:  `total_payment`,  `days_to_departure`.  ●  •    Clusters:  3  distinct  groups  identified.  ●  •    Application:  Targeted  marketing  and  tailored  policy  offers.  
 
 
4.5  Advanced  Risk  Modeling  (XGBoost)  For  maximum  predictive  power,  we  deploy  an  XGBoost  classifier.  This  model  handles  non-linear  
relationships
 
better
 
than
 
standard
 
Random
 
Forests
 
and
 
provides
 
our
 
most
 
accurate
 
risk
 
probability
 
estimates.
 
 
 
---  
Database  Schema  The  application  relies  on  a  normalized  relational  database  schema.  Below  is  the  detailed  structure  of  the  
core
 
tables
 
derived
 
from
 
our
 
system.
 
 
5.1  User  &  Identity  **Table:  User**  
Stores  customer  identity  information.  
●  •    `user_id`:  Unique  identifier  (Primary  Key)  ●  •    `name`:  Full  name  of  the  user  ●  •    `email`:  Contact  email  
●  •    `phone`:  Contact  number  
 
**Table:  Developer**  
Stores  API  access  credentials  for  partners.  
●  •    `developerId`:  Unique  ID  ●  •    `apiKey`:  Secret  key  for  API  access  ●  •    `name`:  Partner  name  ●  •    `email`:  Partner  contact  
 
5.2  Flight  &  Booking  **Table:  Flight**  
Contains  static  and  dynamic  flight  information.  
●  •    `flightId`:  Unique  flight  identifier  ●  •    `flightNumber`:  Operator  code  (e.g.,  AA123)  ●  •    `departureTime`:  Scheduled  departure  ●  •    `arrivalTime`:  Scheduled  arrival  ●  •    `origin`:  Airport  code  ●  •    `destination`:  Airport  code  ●  •    `statusId`:  Foreign  Key  linking  to  StatusLookup  
 
**Table:  statusLookup**  
Reference  table  for  flight  statuses.  
●  •    `statusId`:  PK  ●  •    `statusType`:  Description  (e.g.,  "On  Time",  "Delayed")  ●  •    `code`:  Short  code  
 
**Table:  Booking**  
Links  users  to  flights.  
●  •    `bookingId`:  Unique  booking  ID  ●  •    `user_id`:  FK  to  User  ●  •    `flightId`:  FK  to  Flight  ●  •    `bookingDate`:  Timestamp  of  booking  ●  •    `status`:  Current  booking  status  
 
**Table:  Ticket**  
Granular  ticket  details  within  a  booking.  
●  •    `ticketId`:  Unique  ticket  ID  ●  •    `bookingId`:  FK  to  Booking  ●  •    `seatNumber`:  Assigned  seat  ●  •    `company`:  Airline  name  ●  •    `price`:  Ticket  cost  ●  •    `issueDate`:  Date  of  issuance  ●  •    `isPremium`:  Boolean  flag  for  premium  class  
 
5.3  Insurance  &  Financials  **Table:  InsurancePolicy**  
The  core  parametric  policy  contract.  
●  •    `policyId`:  Unique  policy  ID  ●  •    `bookingId`:  FK  to  Booking  ●  •    `coverageAmount`:  Max  payout  ●  •    `premium`:  Cost  of  the  policy  ●  •    `startDate`:  Policy  effective  date  ●  •    `endDate`:  Policy  expiry  ●  •    `status`:  Active/Expired/Claimed  
 
**Table:  InsuranceClaim**  
Records  of  claims  triggered  by  flight  delays.  
●  •    `claimId`:  Unique  claim  ID  ●  •    `policyId`:  FK  to  InsurancePolicy  ●  •    `claimDate`:  Date  triggered  ●  •    `amount`:  Payout  amount  ●  •    `status`:  Pending/Approved/Rejected  ●  •    `reason`:  Trigger  reason  (e.g.,  "Delay  >  2hrs")  
 **Table:  Payment**  
Ledger  of  all  financial  transactions  (Premiums  &  Payouts).  
●  •    `paymentId`:  Unique  payment  ID  ●  •    `bookingId`:  FK  to  Booking  ●  •    `amount`:  Transaction  value  ●  •    `paymentDate`:  Timestamp  ●  •    `paymentMethod`:  Credit  Card/Crypto  ●  •    `status`:  Success/Failed  
 
---  
Testing  &  Evaluation  
7.1  Methodology  Models  were  evaluated  using  a  80/20  Train-Test  split.  We  utilized  cross-validation  (GridSearchCV)  to  tune  
hyperparameters
 
for
 
Random
 
Forest
 
and
 
XGBoost
 
models.
 
●  •    Classification  Metrics:  Precision,  Recall,  F1-Score,  and  ROC-AUC.  ●  •    Regression  Metrics:  Mean  Squared  Error  (MSE)  and  R-squared.  
 
7.2  Results  ●  •    **Risk  Classifier**:  Achieved  85%  accuracy  in  identifying  delay-prone  flights.  ●  •    **Price  Regressor**:  MSE  reduced  by  15%  compared  to  baseline,  ensuring  profitable  premiums.  ●  •    **XGBoost**:  Outperformed  Random  Forest  by  3%  in  AUC  score,  becoming  the  primary  model  
for
 
risk
 
scoring.
 
 
---  
Future  Improvement  Plans  
8.1  Reinforcement  Learning  for  Pricing  We  plan  to  implement  Deep  Reinforcement  Learning  (DRL)  agents  that  adjust  pricing  strategies  in  
real-time
 
based
 
on
 
the
 
pool's
 
solvency
 
ratio
 
and
 
market
 
demand,
 
effectively
 
"learning"
 
the
 
optimal
 
price
 
elasticity.
 
 8.2  Blockchain  Oracle  Decentralization  Currently,  the  data  science  engine  feeds  the  smart  contracts.  Future  versions  will  utilize  Chainlink  nodes  
to
 
decentralize
 
the
 
data
 
feed,
 
ensuring
 
trustless
 
execution
 
of
 
payouts.
 
 
8.3  Natural  Language  Processing  (NLP)  Implementing  NLP  to  scrape  news  and  social  media  for  early  warning  signals  of  strikes  or  weather  events  
that
 
could
 
cause
 
mass
 
delays,
 
allowing
 
the
 
Risk
 
Pool
 
to
 
pause
 
new
 
policy
 
issuance
 
preventatively.
 
 
 
 
 
 
 